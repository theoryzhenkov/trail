/**
 * Script to compile the TQL Lezer grammar.
 * This is run as a separate step before TypeScript type checking.
 */

import process from 'node:process';
import { readFileSync, writeFileSync, existsSync } from 'node:fs';
import { buildParserFile } from "@lezer/generator";

const grammarPath = "src/query/codemirror/tql.grammar";
const parserOutPath = "src/query/codemirror/parser.ts";
const termsOutPath = "src/query/codemirror/parser.terms.ts";

if (!existsSync(grammarPath)) {
	console.log("No grammar file found at", grammarPath);
	process.exit(0);
}

console.log("Compiling TQL grammar...");

try {
	const grammarText = readFileSync(grammarPath, "utf-8");
	const { parser, terms } = buildParserFile(grammarText, {
		moduleStyle: "es",
		exportName: "parser",
	});
	
	// Fix TypeScript errors in generated code
	let fixedParser = parser.replace(
		/get: \(value\) =>/g,
		"get: (value: string) =>"
	);
	// Add type assertion for spec lookup (use unknown first to satisfy TypeScript)
	fixedParser = fixedParser.replace(
		/spec_Identifier\[value\]/g,
		"(spec_Identifier as unknown as Record<string, number>)[value]"
	);
	
	// Write parser file
	const parserContent = `// This file is generated by @lezer/generator from tql.grammar
// Do not edit directly!

${fixedParser}`;
	
	writeFileSync(parserOutPath, parserContent);
	
	// Write terms file
	const termsContent = `// This file is generated by @lezer/generator from tql.grammar
// Do not edit directly!

${terms}`;
	writeFileSync(termsOutPath, termsContent);
	
	console.log("TQL grammar compiled successfully.");
} catch (err) {
	console.error("Failed to compile TQL grammar:", err.message);
	process.exit(1);
}
