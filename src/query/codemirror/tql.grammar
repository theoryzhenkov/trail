// TQL (Trail Query Language) Lezer Grammar
// 
// This grammar defines the syntax for TQL queries used in the Trail Obsidian plugin.

@top Query { QueryClause+ }

QueryClause {
  Group |
  From |
  Prune |
  Where |
  When |
  Sort |
  Display
}

// ============================================================================
// Clauses
// ============================================================================

Group { kw<"group"> String }

From { kw<"from"> RelationChain ("," RelationChain)* }

RelationChain { RelationSpec (">>" ChainTarget)* }

ChainTarget { RelationSpec | GroupReference | InlineQuery }

RelationSpec { RelationName RelationOption* }

RelationName { Identifier ("." RelationLabel)? }

RelationLabel { Identifier }

RelationOption {
  ":depth" Number |
  ":flatten" Number?
}

Prune { kw<"prune"> expression }

Where { kw<"where"> expression }

When { kw<"when"> expression }

Sort { kw<"sort"> SortKey ("," SortKey)* }

SortKey { SortKeyExpr SortDirection? }

SortKeyExpr { BuiltinPropertyAccess | PropertyAccess }

SortDirection { ":asc" | ":desc" }

Display { kw<"display"> DisplayList }

DisplayList {
  kw<"all"> ("," DisplayItem)* |
  DisplayItem ("," DisplayItem)*
}

DisplayItem { BuiltinPropertyAccess | PropertyAccess }

// ============================================================================
// Expressions (precedence from lowest to highest)
// ============================================================================

expression { OrExpr }

OrExpr { AndExpr (kw<"or"> AndExpr)* }

AndExpr { NotExpr (kw<"and"> NotExpr)* }

NotExpr { (kw<"not"> | "!") NotExpr | CompareExpr }

CompareExpr { ArithExpr (compareOp ArithExpr | InExpr)? }

InExpr { kw<"in"> ArithExpr RangeExpr? }

RangeExpr { ".." ArithExpr }

compareOp { "=" | "!=" | "<" | ">" | "<=" | ">=" | "=?" | "!=?" }

// ArithExpr excludes DateExpr to avoid ambiguity with date offsets
ArithExpr { arithTerm (("+" | "-") arithTerm)* }

arithTerm {
  ParenExpr |
  FunctionCall |
  InlineQuery |
  GroupReference |
  BuiltinPropertyAccess |
  PropertyAccess |
  SimpleLiteral |
  DateExpr
}

// Group reference: @"Name"
GroupReference { "@" String }

// Inline query expression for use in aggregate functions
// Executes a full query recursively and returns the result set
InlineQuery { "@" "(" InlineQueryBody ")" }

InlineQueryBody { InlineClause+ }

InlineClause {
  From |
  Prune |
  Where |
  Sort
}

ParenExpr { "(" expression ")" }

// FunctionName allows keywords that are also valid function names
// This is needed because @specialize makes keywords global
FunctionName { Identifier | kw<"all"> }

FunctionCall { FunctionName "(" ArgList? ")" }

ArgList { expression ("," expression)* }

// Property segment after dot can be identifier or quoted string for special characters
PropertySegment { Identifier | String }

// First segment must be identifier, subsequent can be identifier or string
PropertyAccess { Identifier ("." PropertySegment)* }

// Builtin property access: $file.name, $traversal.depth, $file.properties."special key"
BuiltinPropertyAccess { BuiltinIdentifier ("." PropertySegment)* }

// ============================================================================
// Literals
// ============================================================================

SimpleLiteral {
  String |
  Number |
  Duration |
  Boolean |
  Null
}

// DateExpr is atomic - the parser greedily consumes the offset
// This avoids ambiguity because Duration is lexically distinct from Number
DateExpr { DateBase ~dateoffset DateOffset? }

DateBase {
  DateLiteral |
  RelativeDate
}

DateOffset { ("+" | "-") Duration }

RelativeDate {
  kw<"today"> |
  kw<"yesterday"> |
  kw<"tomorrow"> |
  kw<"startOfWeek"> |
  kw<"endOfWeek">
}

Boolean { @specialize[@name=Boolean]<Identifier, "true" | "false"> }

Null { @specialize[@name=Null]<Identifier, "null"> }

// ============================================================================
// Tokens
// ============================================================================

@tokens {
  whitespace { @whitespace+ }
  
  String { '"' (!["\\] | "\\" _)* '"' }
  
  // Duration must come before Number for correct precedence
  Duration { @digit+ $[dwmy] }
  
  Number { @digit+ ("." @digit+)? }
  
  // Date literal (ISO format YYYY-MM-DD or YYYY-MM-DDTHH:MM:SS)
  DateLiteral { 
    @digit @digit @digit @digit "-" @digit @digit "-" @digit @digit 
    ("T" @digit @digit ":" @digit @digit ":" @digit @digit)?
  }
  
  BuiltinIdentifier { "$" $[a-zA-Z_À-ÿА-я一-龯№] $[a-zA-Z0-9_À-ÿА-я一-龯-№]* }
  
  Identifier { $[a-zA-Z_À-ÿА-я一-龯№] $[a-zA-Z0-9_À-ÿА-я一-龯-№]* }
  
  LineComment { "//" ![\n]* }
  
  // Operators - longer ones first for correct matching
  "!=?" "=?" "!=" "<=" ">=" ".." ">>"
  "=" "<" ">" "+" "-" "!" "."
  "(" ")" "," "@"
  
  @precedence { Duration, Number }
  @precedence { DateLiteral, Number }
  @precedence { "!=?", "!=", "!" }
  @precedence { "=?", "=" }
  @precedence { "<=", "<" }
  @precedence { ">=", ">" }
  @precedence { "..", "." }
  @precedence { ">>", "," }
}

@skip { whitespace | LineComment }

kw<term> { @specialize[@name={term}]<Identifier, term> }

@external propSource highlighting from "./highlight"

@detectDelim
